<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>playwright.connection API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>playwright.connection</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright (c) Microsoft Corporation.
#
# Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import asyncio
import sys
import traceback
from typing import Any, Callable, Dict, Optional, Union

from greenlet import greenlet
from pyee import BaseEventEmitter

from playwright.helper import ParsedMessagePayload, parse_error
from playwright.sync_base import dispatcher_fiber
from playwright.transport import Transport


class Channel(BaseEventEmitter):
    def __init__(self, connection: &#34;Connection&#34;, guid: str) -&gt; None:
        super().__init__()
        self._connection: Connection = connection
        self._guid = guid
        self._object: Optional[ChannelOwner] = None

    async def send(self, method: str, params: Dict = None) -&gt; Any:
        if params is None:
            params = {}
        callback = self._connection._send_message_to_server(self._guid, method, params)
        result = await callback.future
        # Protocol now has named return values, assume result is one level deeper unless
        # there is explicit ambiguity.
        if not result:
            return None
        assert isinstance(result, dict)
        if len(result) == 0:
            return None
        assert len(result) == 1
        key = next(iter(result))
        return result[key]

    def send_no_reply(self, method: str, params: Dict = None) -&gt; None:
        if params is None:
            params = {}
        self._connection._send_message_to_server(self._guid, method, params)


class ChannelOwner(BaseEventEmitter):
    def __init__(
        self,
        parent: Union[&#34;ChannelOwner&#34;, &#34;Connection&#34;],
        type: str,
        guid: str,
        initializer: Dict,
    ) -&gt; None:
        super().__init__()
        self._loop: asyncio.AbstractEventLoop = parent._loop
        self._type = type
        self._guid = guid
        self._connection: Connection = parent._connection if isinstance(
            parent, ChannelOwner
        ) else parent
        self._parent: Optional[ChannelOwner] = parent if isinstance(
            parent, ChannelOwner
        ) else None
        self._objects: Dict[str, &#34;ChannelOwner&#34;] = {}
        self._channel = Channel(self._connection, guid)
        self._channel._object = self
        self._initializer = initializer

        self._connection._objects[guid] = self
        if self._parent:
            self._parent._objects[guid] = self

    def _dispose(self) -&gt; None:
        # Clean up from parent and connection.
        if self._parent:
            del self._parent._objects[self._guid]
        del self._connection._objects[self._guid]

        # Dispose all children.
        for object in list(self._objects.values()):
            object._dispose()
        self._objects.clear()


class ProtocolCallback:
    def __init__(self, loop: asyncio.AbstractEventLoop) -&gt; None:
        self.stack_trace = &#34;&#34;.join(traceback.format_stack()[-10:])
        self.future = loop.create_future()


class RootChannelOwner(ChannelOwner):
    def __init__(self, connection: &#34;Connection&#34;) -&gt; None:
        super().__init__(connection, &#34;&#34;, &#34;&#34;, {})


class Connection:
    def __init__(
        self,
        input: asyncio.StreamReader,
        output: asyncio.StreamWriter,
        object_factory: Any,
        loop: asyncio.AbstractEventLoop,
    ) -&gt; None:
        self._transport = Transport(input, output, loop)
        self._transport.on_message = lambda msg: self._dispatch(msg)
        self._waiting_for_object: Dict[str, Any] = {}
        self._last_id = 0
        self._loop = loop
        self._objects: Dict[str, ChannelOwner] = {}
        self._callbacks: Dict[int, ProtocolCallback] = {}
        self._root_object = RootChannelOwner(self)
        self._object_factory = object_factory
        self._is_sync = False

    def run_sync(self) -&gt; None:
        self._is_sync = True
        self._transport.run_sync()

    def run_async(self) -&gt; None:
        self._transport.run_async()

    def stop_sync(self) -&gt; None:
        self._transport.stop()
        dispatcher_fiber().switch()

    def stop_async(self) -&gt; None:
        self._transport.stop()

    async def wait_for_object_with_known_name(self, guid: str) -&gt; Any:
        if guid in self._objects:
            return self._objects[guid]
        callback = self._loop.create_future()

        def callback_wrapper(result: Any) -&gt; None:
            callback.set_result(result)

        self._waiting_for_object[guid] = callback_wrapper
        return await callback

    def call_on_object_with_known_name(
        self, guid: str, callback: Callable[[Any], None]
    ) -&gt; None:
        self._waiting_for_object[guid] = callback

    def _send_message_to_server(
        self, guid: str, method: str, params: Dict
    ) -&gt; ProtocolCallback:
        self._last_id += 1
        id = self._last_id
        message = dict(
            id=id,
            guid=guid,
            method=method,
            params=self._replace_channels_with_guids(params),
        )
        self._transport.send(message)
        callback = ProtocolCallback(self._loop)
        self._callbacks[id] = callback
        return callback

    def _dispatch(self, msg: ParsedMessagePayload) -&gt; None:
        id = msg.get(&#34;id&#34;)
        if id:
            callback = self._callbacks.pop(id)
            error = msg.get(&#34;error&#34;)
            if error:
                parsed_error = parse_error(error[&#34;error&#34;])  # type: ignore
                parsed_error.stack = callback.stack_trace
                callback.future.set_exception(parsed_error)
            else:
                result = self._replace_guids_with_channels(msg.get(&#34;result&#34;))
                callback.future.set_result(result)
            return

        guid = msg[&#34;guid&#34;]
        method = msg.get(&#34;method&#34;)
        params = msg[&#34;params&#34;]
        if method == &#34;__create__&#34;:
            parent = self._objects[guid]
            self._create_remote_object(
                parent, params[&#34;type&#34;], params[&#34;guid&#34;], params[&#34;initializer&#34;]
            )
            return
        if method == &#34;__dispose__&#34;:
            self._objects[guid]._dispose()
            return

        object = self._objects[guid]
        try:
            if self._is_sync:
                for listener in object._channel.listeners(method):
                    g = greenlet(listener)
                    g.switch(self._replace_guids_with_channels(params))
            else:
                object._channel.emit(method, self._replace_guids_with_channels(params))
        except Exception:
            print(
                &#34;Error dispatching the event&#34;,
                &#34;&#34;.join(traceback.format_exception(*sys.exc_info())),
            )

    def _create_remote_object(
        self, parent: ChannelOwner, type: str, guid: str, initializer: Dict
    ) -&gt; Any:
        result: ChannelOwner
        initializer = self._replace_guids_with_channels(initializer)
        result = self._object_factory(parent, type, guid, initializer)
        if guid in self._waiting_for_object:
            self._waiting_for_object.pop(guid)(result)
        return result

    def _replace_channels_with_guids(self, payload: Any) -&gt; Any:
        if payload is None:
            return payload
        if isinstance(payload, list):
            return list(map(lambda p: self._replace_channels_with_guids(p), payload))
        if isinstance(payload, Channel):
            return dict(guid=payload._guid)
        if isinstance(payload, dict):
            result = {}
            for key in payload:
                result[key] = self._replace_channels_with_guids(payload[key])
            return result
        return payload

    def _replace_guids_with_channels(self, payload: Any) -&gt; Any:
        if payload is None:
            return payload
        if isinstance(payload, list):
            return list(map(lambda p: self._replace_guids_with_channels(p), payload))
        if isinstance(payload, dict):
            if payload.get(&#34;guid&#34;) in self._objects:
                return self._objects[payload[&#34;guid&#34;]]._channel
            result = {}
            for key in payload:
                result[key] = self._replace_guids_with_channels(payload[key])
            return result
        return payload


def from_channel(channel: Channel) -&gt; Any:
    return channel._object


def from_nullable_channel(channel: Optional[Channel]) -&gt; Optional[Any]:
    return channel._object if channel else None</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="playwright.connection.from_channel"><code class="name flex">
<span>def <span class="ident">from_channel</span></span>(<span>channel: <a title="playwright.connection.Channel" href="#playwright.connection.Channel">Channel</a>) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_channel(channel: Channel) -&gt; Any:
    return channel._object</code></pre>
</details>
</dd>
<dt id="playwright.connection.from_nullable_channel"><code class="name flex">
<span>def <span class="ident">from_nullable_channel</span></span>(<span>channel: Union[<a title="playwright.connection.Channel" href="#playwright.connection.Channel">Channel</a>, NoneType]) ‑> Union[Any, NoneType]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_nullable_channel(channel: Optional[Channel]) -&gt; Optional[Any]:
    return channel._object if channel else None</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="playwright.connection.Channel"><code class="flex name class">
<span>class <span class="ident">Channel</span></span>
<span>(</span><span>connection: <a title="playwright.connection.Connection" href="#playwright.connection.Connection">Connection</a>, guid: str)</span>
</code></dt>
<dd>
<div class="desc"><p>The base event emitter class. All other event emitters inherit from
this class.</p>
<p>Most events are registered with an emitter via the <code>on</code> and <code>once</code>
methods, and fired with the <code>emit</code> method. However, pyee event emitters
have two <em>special</em> events:</p>
<ul>
<li>
<p><code>new_listener</code>: Fires whenever a new listener is created. Listeners for
this event do not fire upon their own creation.</p>
</li>
<li>
<p><code>error</code>: When emitted raises an Exception by default, behavior can be
overriden by attaching callback to the event.</p>
</li>
</ul>
<p>For example::</p>
<pre><code>  @ee.on('error')
  def on_error(message):
      logging.err(message)

  ee.emit('error', Exception('something blew up'))
</code></pre>
<p>All callbacks are handled in a synchronous, blocking manner. As in node.js,
raised exceptions are not automatically handled for you&mdash;you must catch
your own exceptions, and treat them accordingly.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Channel(BaseEventEmitter):
    def __init__(self, connection: &#34;Connection&#34;, guid: str) -&gt; None:
        super().__init__()
        self._connection: Connection = connection
        self._guid = guid
        self._object: Optional[ChannelOwner] = None

    async def send(self, method: str, params: Dict = None) -&gt; Any:
        if params is None:
            params = {}
        callback = self._connection._send_message_to_server(self._guid, method, params)
        result = await callback.future
        # Protocol now has named return values, assume result is one level deeper unless
        # there is explicit ambiguity.
        if not result:
            return None
        assert isinstance(result, dict)
        if len(result) == 0:
            return None
        assert len(result) == 1
        key = next(iter(result))
        return result[key]

    def send_no_reply(self, method: str, params: Dict = None) -&gt; None:
        if params is None:
            params = {}
        self._connection._send_message_to_server(self._guid, method, params)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pyee._base.BaseEventEmitter</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="playwright.connection.Channel.send"><code class="name flex">
<span>async def <span class="ident">send</span></span>(<span>self, method: str, params: Dict = None) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def send(self, method: str, params: Dict = None) -&gt; Any:
    if params is None:
        params = {}
    callback = self._connection._send_message_to_server(self._guid, method, params)
    result = await callback.future
    # Protocol now has named return values, assume result is one level deeper unless
    # there is explicit ambiguity.
    if not result:
        return None
    assert isinstance(result, dict)
    if len(result) == 0:
        return None
    assert len(result) == 1
    key = next(iter(result))
    return result[key]</code></pre>
</details>
</dd>
<dt id="playwright.connection.Channel.send_no_reply"><code class="name flex">
<span>def <span class="ident">send_no_reply</span></span>(<span>self, method: str, params: Dict = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_no_reply(self, method: str, params: Dict = None) -&gt; None:
    if params is None:
        params = {}
    self._connection._send_message_to_server(self._guid, method, params)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="playwright.connection.ChannelOwner"><code class="flex name class">
<span>class <span class="ident">ChannelOwner</span></span>
<span>(</span><span>parent: Union[ForwardRef('<a title="playwright.connection.ChannelOwner" href="#playwright.connection.ChannelOwner">ChannelOwner</a>'), ForwardRef('<a title="playwright.connection.Connection" href="#playwright.connection.Connection">Connection</a>')], type: str, guid: str, initializer: Dict)</span>
</code></dt>
<dd>
<div class="desc"><p>The base event emitter class. All other event emitters inherit from
this class.</p>
<p>Most events are registered with an emitter via the <code>on</code> and <code>once</code>
methods, and fired with the <code>emit</code> method. However, pyee event emitters
have two <em>special</em> events:</p>
<ul>
<li>
<p><code>new_listener</code>: Fires whenever a new listener is created. Listeners for
this event do not fire upon their own creation.</p>
</li>
<li>
<p><code>error</code>: When emitted raises an Exception by default, behavior can be
overriden by attaching callback to the event.</p>
</li>
</ul>
<p>For example::</p>
<pre><code>  @ee.on('error')
  def on_error(message):
      logging.err(message)

  ee.emit('error', Exception('something blew up'))
</code></pre>
<p>All callbacks are handled in a synchronous, blocking manner. As in node.js,
raised exceptions are not automatically handled for you&mdash;you must catch
your own exceptions, and treat them accordingly.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ChannelOwner(BaseEventEmitter):
    def __init__(
        self,
        parent: Union[&#34;ChannelOwner&#34;, &#34;Connection&#34;],
        type: str,
        guid: str,
        initializer: Dict,
    ) -&gt; None:
        super().__init__()
        self._loop: asyncio.AbstractEventLoop = parent._loop
        self._type = type
        self._guid = guid
        self._connection: Connection = parent._connection if isinstance(
            parent, ChannelOwner
        ) else parent
        self._parent: Optional[ChannelOwner] = parent if isinstance(
            parent, ChannelOwner
        ) else None
        self._objects: Dict[str, &#34;ChannelOwner&#34;] = {}
        self._channel = Channel(self._connection, guid)
        self._channel._object = self
        self._initializer = initializer

        self._connection._objects[guid] = self
        if self._parent:
            self._parent._objects[guid] = self

    def _dispose(self) -&gt; None:
        # Clean up from parent and connection.
        if self._parent:
            del self._parent._objects[self._guid]
        del self._connection._objects[self._guid]

        # Dispose all children.
        for object in list(self._objects.values()):
            object._dispose()
        self._objects.clear()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pyee._base.BaseEventEmitter</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="playwright.browser.Browser" href="browser.html#playwright.browser.Browser">Browser</a></li>
<li><a title="playwright.browser_context.BrowserContext" href="browser_context.html#playwright.browser_context.BrowserContext">BrowserContext</a></li>
<li><a title="playwright.browser_type.BrowserType" href="browser_type.html#playwright.browser_type.BrowserType">BrowserType</a></li>
<li><a title="playwright.cdp_session.CDPSession" href="cdp_session.html#playwright.cdp_session.CDPSession">CDPSession</a></li>
<li><a title="playwright.connection.RootChannelOwner" href="#playwright.connection.RootChannelOwner">RootChannelOwner</a></li>
<li><a title="playwright.console_message.ConsoleMessage" href="console_message.html#playwright.console_message.ConsoleMessage">ConsoleMessage</a></li>
<li><a title="playwright.dialog.Dialog" href="dialog.html#playwright.dialog.Dialog">Dialog</a></li>
<li><a title="playwright.download.Download" href="download.html#playwright.download.Download">Download</a></li>
<li><a title="playwright.frame.Frame" href="frame.html#playwright.frame.Frame">Frame</a></li>
<li><a title="playwright.js_handle.JSHandle" href="js_handle.html#playwright.js_handle.JSHandle">JSHandle</a></li>
<li><a title="playwright.network.Request" href="network.html#playwright.network.Request">Request</a></li>
<li><a title="playwright.network.Response" href="network.html#playwright.network.Response">Response</a></li>
<li><a title="playwright.network.Route" href="network.html#playwright.network.Route">Route</a></li>
<li><a title="playwright.object_factory.DummyObject" href="object_factory.html#playwright.object_factory.DummyObject">DummyObject</a></li>
<li><a title="playwright.page.BindingCall" href="page.html#playwright.page.BindingCall">BindingCall</a></li>
<li><a title="playwright.page.Page" href="page.html#playwright.page.Page">Page</a></li>
<li><a title="playwright.page.Worker" href="page.html#playwright.page.Worker">Worker</a></li>
<li><a title="playwright.playwright.Playwright" href="playwright.html#playwright.playwright.Playwright">Playwright</a></li>
<li><a title="playwright.selectors.Selectors" href="selectors.html#playwright.selectors.Selectors">Selectors</a></li>
</ul>
</dd>
<dt id="playwright.connection.Connection"><code class="flex name class">
<span>class <span class="ident">Connection</span></span>
<span>(</span><span>input: asyncio.streams.StreamReader, output: asyncio.streams.StreamWriter, object_factory: Any, loop: asyncio.events.AbstractEventLoop)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Connection:
    def __init__(
        self,
        input: asyncio.StreamReader,
        output: asyncio.StreamWriter,
        object_factory: Any,
        loop: asyncio.AbstractEventLoop,
    ) -&gt; None:
        self._transport = Transport(input, output, loop)
        self._transport.on_message = lambda msg: self._dispatch(msg)
        self._waiting_for_object: Dict[str, Any] = {}
        self._last_id = 0
        self._loop = loop
        self._objects: Dict[str, ChannelOwner] = {}
        self._callbacks: Dict[int, ProtocolCallback] = {}
        self._root_object = RootChannelOwner(self)
        self._object_factory = object_factory
        self._is_sync = False

    def run_sync(self) -&gt; None:
        self._is_sync = True
        self._transport.run_sync()

    def run_async(self) -&gt; None:
        self._transport.run_async()

    def stop_sync(self) -&gt; None:
        self._transport.stop()
        dispatcher_fiber().switch()

    def stop_async(self) -&gt; None:
        self._transport.stop()

    async def wait_for_object_with_known_name(self, guid: str) -&gt; Any:
        if guid in self._objects:
            return self._objects[guid]
        callback = self._loop.create_future()

        def callback_wrapper(result: Any) -&gt; None:
            callback.set_result(result)

        self._waiting_for_object[guid] = callback_wrapper
        return await callback

    def call_on_object_with_known_name(
        self, guid: str, callback: Callable[[Any], None]
    ) -&gt; None:
        self._waiting_for_object[guid] = callback

    def _send_message_to_server(
        self, guid: str, method: str, params: Dict
    ) -&gt; ProtocolCallback:
        self._last_id += 1
        id = self._last_id
        message = dict(
            id=id,
            guid=guid,
            method=method,
            params=self._replace_channels_with_guids(params),
        )
        self._transport.send(message)
        callback = ProtocolCallback(self._loop)
        self._callbacks[id] = callback
        return callback

    def _dispatch(self, msg: ParsedMessagePayload) -&gt; None:
        id = msg.get(&#34;id&#34;)
        if id:
            callback = self._callbacks.pop(id)
            error = msg.get(&#34;error&#34;)
            if error:
                parsed_error = parse_error(error[&#34;error&#34;])  # type: ignore
                parsed_error.stack = callback.stack_trace
                callback.future.set_exception(parsed_error)
            else:
                result = self._replace_guids_with_channels(msg.get(&#34;result&#34;))
                callback.future.set_result(result)
            return

        guid = msg[&#34;guid&#34;]
        method = msg.get(&#34;method&#34;)
        params = msg[&#34;params&#34;]
        if method == &#34;__create__&#34;:
            parent = self._objects[guid]
            self._create_remote_object(
                parent, params[&#34;type&#34;], params[&#34;guid&#34;], params[&#34;initializer&#34;]
            )
            return
        if method == &#34;__dispose__&#34;:
            self._objects[guid]._dispose()
            return

        object = self._objects[guid]
        try:
            if self._is_sync:
                for listener in object._channel.listeners(method):
                    g = greenlet(listener)
                    g.switch(self._replace_guids_with_channels(params))
            else:
                object._channel.emit(method, self._replace_guids_with_channels(params))
        except Exception:
            print(
                &#34;Error dispatching the event&#34;,
                &#34;&#34;.join(traceback.format_exception(*sys.exc_info())),
            )

    def _create_remote_object(
        self, parent: ChannelOwner, type: str, guid: str, initializer: Dict
    ) -&gt; Any:
        result: ChannelOwner
        initializer = self._replace_guids_with_channels(initializer)
        result = self._object_factory(parent, type, guid, initializer)
        if guid in self._waiting_for_object:
            self._waiting_for_object.pop(guid)(result)
        return result

    def _replace_channels_with_guids(self, payload: Any) -&gt; Any:
        if payload is None:
            return payload
        if isinstance(payload, list):
            return list(map(lambda p: self._replace_channels_with_guids(p), payload))
        if isinstance(payload, Channel):
            return dict(guid=payload._guid)
        if isinstance(payload, dict):
            result = {}
            for key in payload:
                result[key] = self._replace_channels_with_guids(payload[key])
            return result
        return payload

    def _replace_guids_with_channels(self, payload: Any) -&gt; Any:
        if payload is None:
            return payload
        if isinstance(payload, list):
            return list(map(lambda p: self._replace_guids_with_channels(p), payload))
        if isinstance(payload, dict):
            if payload.get(&#34;guid&#34;) in self._objects:
                return self._objects[payload[&#34;guid&#34;]]._channel
            result = {}
            for key in payload:
                result[key] = self._replace_guids_with_channels(payload[key])
            return result
        return payload</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="playwright.connection.Connection.call_on_object_with_known_name"><code class="name flex">
<span>def <span class="ident">call_on_object_with_known_name</span></span>(<span>self, guid: str, callback: Callable[[Any], NoneType]) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call_on_object_with_known_name(
    self, guid: str, callback: Callable[[Any], None]
) -&gt; None:
    self._waiting_for_object[guid] = callback</code></pre>
</details>
</dd>
<dt id="playwright.connection.Connection.run_async"><code class="name flex">
<span>def <span class="ident">run_async</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_async(self) -&gt; None:
    self._transport.run_async()</code></pre>
</details>
</dd>
<dt id="playwright.connection.Connection.run_sync"><code class="name flex">
<span>def <span class="ident">run_sync</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_sync(self) -&gt; None:
    self._is_sync = True
    self._transport.run_sync()</code></pre>
</details>
</dd>
<dt id="playwright.connection.Connection.stop_async"><code class="name flex">
<span>def <span class="ident">stop_async</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop_async(self) -&gt; None:
    self._transport.stop()</code></pre>
</details>
</dd>
<dt id="playwright.connection.Connection.stop_sync"><code class="name flex">
<span>def <span class="ident">stop_sync</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop_sync(self) -&gt; None:
    self._transport.stop()
    dispatcher_fiber().switch()</code></pre>
</details>
</dd>
<dt id="playwright.connection.Connection.wait_for_object_with_known_name"><code class="name flex">
<span>async def <span class="ident">wait_for_object_with_known_name</span></span>(<span>self, guid: str) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def wait_for_object_with_known_name(self, guid: str) -&gt; Any:
    if guid in self._objects:
        return self._objects[guid]
    callback = self._loop.create_future()

    def callback_wrapper(result: Any) -&gt; None:
        callback.set_result(result)

    self._waiting_for_object[guid] = callback_wrapper
    return await callback</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="playwright.connection.ProtocolCallback"><code class="flex name class">
<span>class <span class="ident">ProtocolCallback</span></span>
<span>(</span><span>loop: asyncio.events.AbstractEventLoop)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProtocolCallback:
    def __init__(self, loop: asyncio.AbstractEventLoop) -&gt; None:
        self.stack_trace = &#34;&#34;.join(traceback.format_stack()[-10:])
        self.future = loop.create_future()</code></pre>
</details>
</dd>
<dt id="playwright.connection.RootChannelOwner"><code class="flex name class">
<span>class <span class="ident">RootChannelOwner</span></span>
<span>(</span><span>connection: <a title="playwright.connection.Connection" href="#playwright.connection.Connection">Connection</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>The base event emitter class. All other event emitters inherit from
this class.</p>
<p>Most events are registered with an emitter via the <code>on</code> and <code>once</code>
methods, and fired with the <code>emit</code> method. However, pyee event emitters
have two <em>special</em> events:</p>
<ul>
<li>
<p><code>new_listener</code>: Fires whenever a new listener is created. Listeners for
this event do not fire upon their own creation.</p>
</li>
<li>
<p><code>error</code>: When emitted raises an Exception by default, behavior can be
overriden by attaching callback to the event.</p>
</li>
</ul>
<p>For example::</p>
<pre><code>  @ee.on('error')
  def on_error(message):
      logging.err(message)

  ee.emit('error', Exception('something blew up'))
</code></pre>
<p>All callbacks are handled in a synchronous, blocking manner. As in node.js,
raised exceptions are not automatically handled for you&mdash;you must catch
your own exceptions, and treat them accordingly.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RootChannelOwner(ChannelOwner):
    def __init__(self, connection: &#34;Connection&#34;) -&gt; None:
        super().__init__(connection, &#34;&#34;, &#34;&#34;, {})</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="playwright.connection.ChannelOwner" href="#playwright.connection.ChannelOwner">ChannelOwner</a></li>
<li>pyee._base.BaseEventEmitter</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="playwright" href="index.html">playwright</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="playwright.connection.from_channel" href="#playwright.connection.from_channel">from_channel</a></code></li>
<li><code><a title="playwright.connection.from_nullable_channel" href="#playwright.connection.from_nullable_channel">from_nullable_channel</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="playwright.connection.Channel" href="#playwright.connection.Channel">Channel</a></code></h4>
<ul class="">
<li><code><a title="playwright.connection.Channel.send" href="#playwright.connection.Channel.send">send</a></code></li>
<li><code><a title="playwright.connection.Channel.send_no_reply" href="#playwright.connection.Channel.send_no_reply">send_no_reply</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.connection.ChannelOwner" href="#playwright.connection.ChannelOwner">ChannelOwner</a></code></h4>
</li>
<li>
<h4><code><a title="playwright.connection.Connection" href="#playwright.connection.Connection">Connection</a></code></h4>
<ul class="">
<li><code><a title="playwright.connection.Connection.call_on_object_with_known_name" href="#playwright.connection.Connection.call_on_object_with_known_name">call_on_object_with_known_name</a></code></li>
<li><code><a title="playwright.connection.Connection.run_async" href="#playwright.connection.Connection.run_async">run_async</a></code></li>
<li><code><a title="playwright.connection.Connection.run_sync" href="#playwright.connection.Connection.run_sync">run_sync</a></code></li>
<li><code><a title="playwright.connection.Connection.stop_async" href="#playwright.connection.Connection.stop_async">stop_async</a></code></li>
<li><code><a title="playwright.connection.Connection.stop_sync" href="#playwright.connection.Connection.stop_sync">stop_sync</a></code></li>
<li><code><a title="playwright.connection.Connection.wait_for_object_with_known_name" href="#playwright.connection.Connection.wait_for_object_with_known_name">wait_for_object_with_known_name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.connection.ProtocolCallback" href="#playwright.connection.ProtocolCallback">ProtocolCallback</a></code></h4>
</li>
<li>
<h4><code><a title="playwright.connection.RootChannelOwner" href="#playwright.connection.RootChannelOwner">RootChannelOwner</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>